syntax = "proto3";

package distributed_inference;

// ============================================================
// Message Types
// ============================================================

// Serialized tensor data
message TensorData {
  bytes data = 1;         // Serialized tensor bytes (torch.save format)
  repeated int64 shape = 2;
  string dtype = 3;       // e.g. "float16", "float32"
}

// Activation data passed between nodes during forward pass
message ActivationData {
  TensorData hidden_states = 1;
  TensorData attention_mask = 2;
  TensorData position_ids = 3;
  string request_id = 4;
  int32 current_layer = 5;  // Track which layer we're at
  bool use_cache = 6;
  bool reset_cache = 7;
  int64 cache_position = 8;
  bool is_prefill = 9;
}

// Node capability information
message NodeInfo {
  string node_id = 1;
  string address = 2;       // host:port
  int64 vram_mb = 3;
  float compute_tflops = 4;
  float bandwidth_mbps = 5;
  string device_type = 6;   // "cuda" or "cpu"
  string device_name = 7;
  int64 sram_mb = 8;
  float latency_ms = 9;
  float effective_bandwidth_mbps = 10;
}

// Node health/status report
message NodeStatus {
  string node_id = 1;
  enum Status {
    IDLE = 0;
    LOADING = 1;
    READY = 2;
    BUSY = 3;
    ERROR = 4;
  }
  Status status = 2;
  int64 vram_used_mb = 3;
  int64 vram_total_mb = 4;
  repeated int32 assigned_layers = 5;
  float load_percent = 6;
  int64 timestamp_ms = 7;
  int32 active_requests = 8;
  int32 queue_depth = 9;
  int64 estimated_free_vram_mb = 10;
}

// Shard assignment from coordinator to node
message ShardAssignment {
  string model_name = 1;
  int32 start_layer = 2;
  int32 end_layer = 3;       // exclusive
  bool has_embedding = 4;    // first node holds embedding layer
  bool has_lm_head = 5;      // last node holds lm_head
  string dtype = 6;          // "float16" or "float32"
}

// Registration acknowledgement
message RegistrationAck {
  bool success = 1;
  string message = 2;
  string assigned_node_id = 3;

  enum AdmissionStatus {
    ADMITTED = 0;
    REJECTED = 1;
  }
  AdmissionStatus admission_status = 4;
  string rejection_reason = 5;
  string rebalance_plan_version = 6;
}

// Inference request from client
message InferenceRequest {
  string request_id = 1;
  string prompt = 2;
  int32 max_tokens = 3;
  float temperature = 4;
  float top_p = 5;
  int32 top_k = 6;
}

// Inference response to client
message InferenceResponse {
  string request_id = 1;
  string generated_text = 2;
  int32 tokens_generated = 3;
  float total_latency_ms = 4;
  repeated float per_hop_latency_ms = 5;
  float tokens_per_second = 6;
}

message CancelInferenceRequest {
  string request_id = 1;
  string reason = 2;
}

message CancelInferenceResponse {
  bool accepted = 1;
  string status = 2;
}

// Per-hop telemetry event emitted during streaming inference.
message HopEvent {
  int32 step = 1;
  int32 hop_index = 2;
  string node_id = 3;
  string address = 4;
  int32 start_layer = 5;
  int32 end_layer = 6;
  float hop_latency_ms = 7;
}

// Token telemetry event emitted during streaming inference.
message TokenEvent {
  int32 step = 1;
  int32 token_id = 2;
  string token_text = 3;
  string accumulated_text = 4;
}

// Streaming inference event. Exactly one payload variant is set.
message InferenceEvent {
  string request_id = 1;
  int64 timestamp_ms = 2;

  oneof payload {
    HopEvent hop = 3;
    TokenEvent token = 4;
    InferenceResponse completed = 5;
    string error = 6;
  }
}

// Simple ack/ping
message Empty {}

message HeartbeatResponse {
  NodeStatus status = 1;
}

message CacheControl {
  string request_id = 1;
  bool clear_all = 2;
}

// ============================================================
// Node Service — runs on each node
// ============================================================
service NodeService {
  // Coordinator tells node to load specific model layers
  rpc LoadModelShard(ShardAssignment) returns (NodeStatus);

  // Forward pass: receive activations, process through local layers, return activations
  rpc RunForward(ActivationData) returns (ActivationData);

  // Health check
  rpc Heartbeat(Empty) returns (HeartbeatResponse);

  // Unload current shard (for re-partitioning)
  rpc UnloadShard(Empty) returns (NodeStatus);

  // Clear cache state for a specific request or all requests.
  rpc ClearRequestCache(CacheControl) returns (Empty);

  // Cancel an in-flight request on this node.
  rpc CancelRequest(CacheControl) returns (Empty);
}

// ============================================================
// Coordinator Service — runs on the coordinator
// ============================================================
service CoordinatorService {
  // Node registers itself with the coordinator
  rpc RegisterNode(NodeInfo) returns (RegistrationAck);

  // Node sends periodic health reports
  rpc ReportHealth(NodeStatus) returns (Empty);

  // Client submits an inference request
  rpc SubmitInference(InferenceRequest) returns (InferenceResponse);

  // Client submits an inference request and receives streaming events.
  rpc SubmitInferenceStream(InferenceRequest) returns (stream InferenceEvent);

  // Client requests cancellation of an in-flight inference request.
  rpc CancelInference(CancelInferenceRequest) returns (CancelInferenceResponse);
}
